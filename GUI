-- Enhanced Follow Player GUI for Mobile & PC
-- Version: 1.8
-- FIXED: Random side/follow choice on radius entry, Anti-seat with victim seat detection

local player = game.Players.LocalPlayer
local PlayerGui = player:WaitForChild("PlayerGui")

-- Clean up old GUI if exists
if PlayerGui:FindFirstChild("FollowPlayerGui") then
	PlayerGui.FollowPlayerGui:Destroy()
end

local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "FollowPlayerGui"
ScreenGui.ResetOnSpawn = false
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ScreenGui.Parent = PlayerGui

local MainFrame = Instance.new("Frame")
MainFrame.Name = "MainFrame"
MainFrame.Parent = ScreenGui
MainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
MainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
MainFrame.Size = UDim2.new(0, 380, 0, 280)
MainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
MainFrame.BorderSizePixel = 0
MainFrame.Active = true
MainFrame.Draggable = true

local MainFrameCorner = Instance.new("UICorner")
MainFrameCorner.CornerRadius = UDim.new(0, 16)
MainFrameCorner.Parent = MainFrame

local MainFrameStroke = Instance.new("UIStroke")
MainFrameStroke.Color = Color3.fromRGB(100, 100, 255)
MainFrameStroke.Thickness = 2
MainFrameStroke.Transparency = 0.5
MainFrameStroke.Parent = MainFrame

local Header = Instance.new("Frame")
Header.Name = "Header"
Header.Parent = MainFrame
Header.Size = UDim2.new(1, 0, 0, 60)
Header.BackgroundColor3 = Color3.fromRGB(45, 45, 55)
Header.BorderSizePixel = 0

local HeaderCorner = Instance.new("UICorner")
HeaderCorner.CornerRadius = UDim.new(0, 16)
HeaderCorner.Parent = Header

local Title = Instance.new("TextLabel")
Title.Name = "Title"
Title.Parent = Header
Title.Position = UDim2.new(0, 15, 0, 0)
Title.Size = UDim2.new(1, -80, 1, 0)
Title.BackgroundTransparency = 1
Title.Font = Enum.Font.GothamBold
Title.Text = "üë§ Follow Player"
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.TextSize = 22
Title.TextXAlignment = Enum.TextXAlignment.Left

local MinimizeButton = Instance.new("TextButton")
MinimizeButton.Name = "MinimizeButton"
MinimizeButton.Parent = Header
MinimizeButton.AnchorPoint = Vector2.new(1, 0.5)
MinimizeButton.Position = UDim2.new(1, -10, 0.5, 0)
MinimizeButton.Size = UDim2.new(0, 40, 0, 40)
MinimizeButton.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
MinimizeButton.BorderSizePixel = 0
MinimizeButton.Font = Enum.Font.GothamBold
MinimizeButton.Text = "‚àí"
MinimizeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
MinimizeButton.TextSize = 24
MinimizeButton.AutoButtonColor = false

local MinimizeCorner = Instance.new("UICorner")
MinimizeCorner.CornerRadius = UDim.new(0, 10)
MinimizeCorner.Parent = MinimizeButton

local ContentContainer = Instance.new("Frame")
ContentContainer.Name = "ContentContainer"
ContentContainer.Parent = MainFrame
ContentContainer.Position = UDim2.new(0, 0, 0, 70)
ContentContainer.Size = UDim2.new(1, 0, 1, -70)
ContentContainer.BackgroundTransparency = 1

local SearchLabel = Instance.new("TextLabel")
SearchLabel.Name = "SearchLabel"
SearchLabel.Parent = ContentContainer
SearchLabel.Position = UDim2.new(0, 20, 0, 15)
SearchLabel.Size = UDim2.new(1, -40, 0, 20)
SearchLabel.BackgroundTransparency = 1
SearchLabel.Font = Enum.Font.Gotham
SearchLabel.Text = "Player Username or Display Name"
SearchLabel.TextColor3 = Color3.fromRGB(180, 180, 190)
SearchLabel.TextSize = 14
SearchLabel.TextXAlignment = Enum.TextXAlignment.Left

local SearchBarContainer = Instance.new("Frame")
SearchBarContainer.Name = "SearchBarContainer"
SearchBarContainer.Parent = ContentContainer
SearchBarContainer.Position = UDim2.new(0, 20, 0, 45)
SearchBarContainer.Size = UDim2.new(1, -40, 0, 50)
SearchBarContainer.BackgroundColor3 = Color3.fromRGB(45, 45, 55)
SearchBarContainer.BorderSizePixel = 0

local SearchBarCorner = Instance.new("UICorner")
SearchBarCorner.CornerRadius = UDim.new(0, 10)
SearchBarCorner.Parent = SearchBarContainer

local SearchIcon = Instance.new("TextLabel")
SearchIcon.Name = "SearchIcon"
SearchIcon.Parent = SearchBarContainer
SearchIcon.Position = UDim2.new(0, 12, 0, 0)
SearchIcon.Size = UDim2.new(0, 30, 1, 0)
SearchIcon.BackgroundTransparency = 1
SearchIcon.Font = Enum.Font.GothamBold
SearchIcon.Text = "üîç"
SearchIcon.TextColor3 = Color3.fromRGB(150, 150, 160)
SearchIcon.TextSize = 20

local SearchBar = Instance.new("TextBox")
SearchBar.Name = "SearchBar"
SearchBar.Parent = SearchBarContainer
SearchBar.Position = UDim2.new(0, 45, 0, 0)
SearchBar.Size = UDim2.new(1, -55, 1, 0)
SearchBar.BackgroundTransparency = 1
SearchBar.Font = Enum.Font.Gotham
SearchBar.PlaceholderColor3 = Color3.fromRGB(100, 100, 110)
SearchBar.PlaceholderText = "Enter player name..."
SearchBar.Text = ""
SearchBar.TextColor3 = Color3.fromRGB(255, 255, 255)
SearchBar.TextSize = 16
SearchBar.TextXAlignment = Enum.TextXAlignment.Left
SearchBar.ClearTextOnFocus = false

local ButtonsContainer = Instance.new("Frame")
ButtonsContainer.Name = "ButtonsContainer"
ButtonsContainer.Parent = ContentContainer
ButtonsContainer.Position = UDim2.new(0, 20, 0, 120)
ButtonsContainer.Size = UDim2.new(1, -40, 0, 50)
ButtonsContainer.BackgroundTransparency = 1

local ButtonsLayout = Instance.new("UIListLayout")
ButtonsLayout.Parent = ButtonsContainer
ButtonsLayout.FillDirection = Enum.FillDirection.Horizontal
ButtonsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
ButtonsLayout.VerticalAlignment = Enum.VerticalAlignment.Center
ButtonsLayout.Padding = UDim.new(0, 15)

local FollowButton = Instance.new("TextButton")
FollowButton.Name = "FollowButton"
FollowButton.Parent = ButtonsContainer
FollowButton.Size = UDim2.new(0, 155, 0, 50)
FollowButton.BackgroundColor3 = Color3.fromRGB(80, 120, 255)
FollowButton.BorderSizePixel = 0
FollowButton.Font = Enum.Font.GothamBold
FollowButton.Text = "‚úì Follow"
FollowButton.TextColor3 = Color3.fromRGB(255, 255, 255)
FollowButton.TextSize = 18
FollowButton.AutoButtonColor = false

local FollowCorner = Instance.new("UICorner")
FollowCorner.CornerRadius = UDim.new(0, 10)
FollowCorner.Parent = FollowButton

local CancelButton = Instance.new("TextButton")
CancelButton.Name = "CancelButton"
CancelButton.Parent = ButtonsContainer
CancelButton.Size = UDim2.new(0, 155, 0, 50)
CancelButton.BackgroundColor3 = Color3.fromRGB(200, 60, 60)
CancelButton.BorderSizePixel = 0
CancelButton.Font = Enum.Font.GothamBold
CancelButton.Text = "‚úï Cancel"
CancelButton.TextColor3 = Color3.fromRGB(255, 255, 255)
CancelButton.TextSize = 18
CancelButton.AutoButtonColor = false

local CancelCorner = Instance.new("UICorner")
CancelCorner.CornerRadius = UDim.new(0, 10)
CancelCorner.Parent = CancelButton

local StatusLabel = Instance.new("TextLabel")
StatusLabel.Name = "StatusLabel"
StatusLabel.Parent = ContentContainer
StatusLabel.Position = UDim2.new(0, 20, 1, -35)
StatusLabel.Size = UDim2.new(1, -40, 0, 25)
StatusLabel.BackgroundTransparency = 1
StatusLabel.Font = Enum.Font.Gotham
StatusLabel.Text = "Ready"
StatusLabel.TextColor3 = Color3.fromRGB(120, 255, 120)
StatusLabel.TextSize = 14
StatusLabel.TextXAlignment = Enum.TextXAlignment.Center

local function updateForScreenSize()
	local viewportSize = workspace.CurrentCamera.ViewportSize
	local isMobile = viewportSize.X < 600

	if isMobile then
		MainFrame.Size = UDim2.new(0.9, 0, 0, 300)
		Title.TextSize = 18
		SearchBar.TextSize = 14
		FollowButton.Size = UDim2.new(0, 140, 0, 50)
		CancelButton.Size = UDim2.new(0, 140, 0, 50)
		ButtonsLayout.Padding = UDim.new(0, 10)
	else
		MainFrame.Size = UDim2.new(0, 380, 0, 280)
		Title.TextSize = 22
		SearchBar.TextSize = 16
		FollowButton.Size = UDim2.new(0, 155, 0, 50)
		CancelButton.Size = UDim2.new(0, 155, 0, 50)
		ButtonsLayout.Padding = UDim.new(0, 15)
	end
end

workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(updateForScreenSize)
updateForScreenSize()

local function addButtonHover(button, normalColor, hoverColor, pressColor)
	button.MouseEnter:Connect(function()
		button.BackgroundColor3 = hoverColor
	end)

	button.MouseLeave:Connect(function()
		button.BackgroundColor3 = normalColor
	end)

	button.MouseButton1Down:Connect(function()
		button.BackgroundColor3 = pressColor
	end)

	button.MouseButton1Up:Connect(function()
		button.BackgroundColor3 = hoverColor
	end)
end

addButtonHover(
	FollowButton,
	Color3.fromRGB(80, 120, 255),
	Color3.fromRGB(100, 140, 255),
	Color3.fromRGB(60, 100, 235)
)

addButtonHover(
	CancelButton,
	Color3.fromRGB(200, 60, 60),
	Color3.fromRGB(220, 80, 80),
	Color3.fromRGB(180, 40, 40)
)

addButtonHover(
	MinimizeButton,
	Color3.fromRGB(60, 60, 70),
	Color3.fromRGB(80, 80, 90),
	Color3.fromRGB(50, 50, 60)
)

local minimized = false
MinimizeButton.MouseButton1Click:Connect(function()
	minimized = not minimized

	if minimized then
		ContentContainer.Visible = false
		MainFrame.Size = UDim2.new(0, 380, 0, 60)
		MinimizeButton.Text = "+"
		MainFrame.Draggable = false
	else
		ContentContainer.Visible = true
		updateForScreenSize()
		MinimizeButton.Text = "‚àí"
		MainFrame.Draggable = true
	end
end)

local UserInputService = game:GetService("UserInputService")
local dragging = false
local dragInput, dragStart, startPos

local function update(input)
	local delta = input.Position - dragStart
	MainFrame.Position = UDim2.new(
		startPos.X.Scale,
		startPos.X.Offset + delta.X,
		startPos.Y.Scale,
		startPos.Y.Offset + delta.Y
	)
end

Header.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		dragging = true
		dragStart = input.Position
		startPos = MainFrame.Position

		input.Changed:Connect(function()
			if input.UserInputState == Enum.UserInputState.End then
				dragging = false
			end
		end)
	end
end)

UserInputService.InputChanged:Connect(function(input)
	if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
		update(input)
	end
end)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local PathfindingService = game:GetService("PathfindingService")

local targetPlayer = nil
local isFollowing = false
local followConnection = nil

local STOP_DISTANCE = 8
local MAX_DISTANCE = 50
local UPDATE_RATE = 0.2
local STORED_POSITIONS = {}
local MAX_HISTORY = 60
local MIMIC_DELAY = 15

-- Looking behavior variables - UPDATED
local LOOK_DURATION = 1.5  -- Target must look at follower for 1.5 seconds
local LOOK_AWAY_DELAY = 1.5  -- CHANGED: 1.5 second timer after target looks away (was 2)
local LOOK_AT_DIRECTION_BRIEFLY = 0.5  -- Look at target's direction for just 0.5 seconds (was 3)

-- State tracking
local isBeingLookedAt = false
local lookStartTime = 0
local lookAwayStartTime = 0
local isLookingBack = false
local shouldLookAtDirection = false
local lookAtDirectionTime = 0

-- NEW: Behavior state tracking
local wasInRadius = false
local currentBehavior = nil  -- "left", "right", or "follow"
local isExecutingBehavior = false
local lastDistanceUpdate = 0

-- ANTI-SEAT SYSTEM
local antiSeatConnection = nil
local antiSeatActive = false

local function checkVictimSeated(targetHumanoid)
	return targetHumanoid and targetHumanoid.Sit
end

local function activateAntiSeat()
	if antiSeatActive then return end

	local character = player.Character
	if character then
		local humanoid = character:FindFirstChild("Humanoid")
		if humanoid then
			-- Disconnect old connection if exists
			if antiSeatConnection then
				antiSeatConnection:Disconnect()
				antiSeatConnection = nil
			end

			antiSeatConnection = humanoid.Seated:Connect(function(isSeated, seat)
				if isSeated then
					-- Check if victim is also seated
					local victimSeated = false
					if targetPlayer and targetPlayer.Character then
						local targetHumanoid = targetPlayer.Character:FindFirstChild("Humanoid")
						if targetHumanoid and checkVictimSeated(targetHumanoid) then
							victimSeated = true
							print("Anti-seat: Victim is seated, allowing follower to sit")
							return -- Allow follower to sit if victim is also seated
						end
					end

					-- Victim is NOT seated, force follower to stand up
					task.wait(0.3)

					-- Force unseat
					humanoid.Sit = false
					if seat then
						seat:Sit(nil)
					end

					-- Force jump properly
					humanoid:ChangeState(Enum.HumanoidStateType.Jumping)

					print("Anti-seat: Forced to jump off seat (victim is not seated)")
				end
			end)
			antiSeatActive = true
			print("Anti-seat system ACTIVATED (following)")
		end
	end
end

local function deactivateAntiSeat()
	if not antiSeatActive then return end

	if antiSeatConnection then
		antiSeatConnection:Disconnect()
		antiSeatConnection = nil
	end
	antiSeatActive = false
	print("Anti-seat system DEACTIVATED (not following)")
end

local function findPlayer(searchText)
	if searchText == "" then
		return nil
	end

	local searchLower = searchText:lower()
	local matchingPlayers = {}

	for _, otherPlayer in pairs(Players:GetPlayers()) do
		if otherPlayer ~= player then
			local usernameLower = otherPlayer.Name:lower()
			local displayLower = otherPlayer.DisplayName:lower()

			if usernameLower:sub(1, #searchLower) == searchLower or 
				displayLower:sub(1, #searchLower) == searchLower or
				usernameLower:find(searchLower, 1, true) or 
				displayLower:find(searchLower, 1, true) then
				table.insert(matchingPlayers, otherPlayer)
			end
		end
	end

	if #matchingPlayers > 0 then
		return matchingPlayers[1]
	end

	return nil
end

-- Function to check if target is looking at follower (22 DEGREES)
local function isTargetLookingAtFollower(targetRoot, followerRoot)
	if not targetRoot or not followerRoot then return false end

	-- Get direction from target to follower
	local toFollower = (followerRoot.Position - targetRoot.Position).Unit

	-- Get target's current look direction (forward vector of HumanoidRootPart)
	local targetLookDirection = targetRoot.CFrame.LookVector

	-- Check if target is looking roughly at follower (within 22 degrees)
	local dotProduct = targetLookDirection:Dot(toFollower)
	local angle = math.deg(math.acos(math.clamp(dotProduct, -1, 1)))

	return angle < 22  -- Looking within 22 degrees counts as "looking at"
end

-- NEW: Function to get stay beside position
local function getStayBesidePosition(targetRoot, side)
	if side == "left" then
		return targetRoot.CFrame * CFrame.new(-4, 0, 0)
	elseif side == "right" then
		return targetRoot.CFrame * CFrame.new(4, 0, 0)
	end
	return targetRoot.CFrame
end

local function stopFollowing()
	isFollowing = false
	targetPlayer = nil
	isBeingLookedAt = false
	isLookingBack = false
	shouldLookAtDirection = false
	wasInRadius = false
	currentBehavior = nil
	isExecutingBehavior = false

	-- DEACTIVATE anti-seat when stopping following
	deactivateAntiSeat()

	if followConnection then
		followConnection:Disconnect()
		followConnection = nil
	end

	local character = player.Character
	if character then
		local humanoid = character:FindFirstChild("Humanoid")
		if humanoid then
			humanoid:Move(Vector3.new(0, 0, 0))
		end
	end

	STORED_POSITIONS = {}
end

-- Function to make character look at a position
local function lookAtPosition(character, targetPosition)
	local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
	if not humanoidRootPart then return end

	-- Calculate direction to look
	local lookDirection = (targetPosition - humanoidRootPart.Position).Unit
	lookDirection = Vector3.new(lookDirection.X, 0, lookDirection.Z) -- Keep horizontal only

	-- Set the character's look direction
	humanoidRootPart.CFrame = CFrame.new(humanoidRootPart.Position, humanoidRootPart.Position + lookDirection)
end

-- Function to make character look in a specific direction
local function lookInDirection(character, direction)
	local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
	if not humanoidRootPart then return end

	-- Normalize the direction
	direction = direction.Unit
	direction = Vector3.new(direction.X, 0, direction.Z) -- Keep horizontal only

	-- Set the character's look direction
	humanoidRootPart.CFrame = CFrame.new(humanoidRootPart.Position, humanoidRootPart.Position + direction)
end

-- Get a point in front of the target where they're looking
local function getPointInTargetLookDirection(targetRoot, distance)
	local lookDirection = targetRoot.CFrame.LookVector
	return targetRoot.Position + (lookDirection * distance)
end

local function startFollowing()
	if followConnection then
		followConnection:Disconnect()
	end

	-- ACTIVATE anti-seat when starting to follow
	activateAntiSeat()

	local lastUpdate = 0
	STORED_POSITIONS = {}
	isBeingLookedAt = false
	isLookingBack = false
	shouldLookAtDirection = false
	lookStartTime = 0
	lookAwayStartTime = 0
	lookAtDirectionTime = 0

	-- NEW: Reset behavior states
	wasInRadius = false
	currentBehavior = nil
	isExecutingBehavior = false
	lastDistanceUpdate = 0

	followConnection = RunService.Heartbeat:Connect(function(deltaTime)
		if not isFollowing or not targetPlayer or not targetPlayer.Parent then
			stopFollowing()
			StatusLabel.Text = "Target player left"
			StatusLabel.TextColor3 = Color3.fromRGB(255, 200, 100)
			return
		end

		local character = player.Character
		local targetChar = targetPlayer.Character

		if not character or not targetChar then return end

		local humanoid = character:FindFirstChild("Humanoid")
		local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
		local targetRoot = targetChar:FindFirstChild("HumanoidRootPart")
		local targetHumanoid = targetChar:FindFirstChild("Humanoid")

		if not humanoid or not humanoidRootPart or not targetRoot or not targetHumanoid then return end

		local distance = (targetRoot.Position - humanoidRootPart.Position).Magnitude
		local currentTime = tick()

		-- NEW: Random behavior selection when entering radius
		if distance <= STOP_DISTANCE then
			if not wasInRadius then
				-- Just entered radius, choose random behavior
				wasInRadius = true
				local randomChoice = math.random(1, 3)  -- 1: left, 2: right, 3: follow

				if randomChoice == 1 then
					currentBehavior = "left"
					StatusLabel.Text = "Moving to left side"
					StatusLabel.TextColor3 = Color3.fromRGB(150, 255, 150)
				elseif randomChoice == 2 then
					currentBehavior = "right"
					StatusLabel.Text = "Moving to right side"
					StatusLabel.TextColor3 = Color3.fromRGB(150, 255, 150)
				else
					currentBehavior = "follow"
					StatusLabel.Text = "Following directly"
					StatusLabel.TextColor3 = Color3.fromRGB(100, 200, 255)
				end

				print("Entered radius, chosen behavior: " .. currentBehavior)
				isExecutingBehavior = true
			end
		else
			-- Left radius, reset for next entry
			wasInRadius = false
			currentBehavior = nil
			isExecutingBehavior = false
		end

		-- NEW: Execute chosen behavior
		if isExecutingBehavior and currentBehavior then
			if currentBehavior == "left" or currentBehavior == "right" then
				-- Move to the chosen side
				local sidePos = getStayBesidePosition(targetRoot, currentBehavior)
				humanoid:MoveTo(sidePos.Position)

				-- Check if we reached the side position
				local distanceToSide = (sidePos.Position - humanoidRootPart.Position).Magnitude

				if distanceToSide < 2 then
					-- Reached side, now switch to follow mode
					currentBehavior = "follow"
					isExecutingBehavior = false
					print("Reached " .. currentBehavior .. " side, switching to follow mode")
				else
					-- Still moving to side
					StatusLabel.Text = "Moving to " .. currentBehavior .. " side (" .. math.floor(distance) .. " studs)"
					StatusLabel.TextColor3 = Color3.fromRGB(150, 255, 150)
					return -- Skip other behaviors while moving to side
				end
			end
		end

		-- Update status text
		if currentTime - lastDistanceUpdate > 0.5 then -- Update every 0.5 seconds
			if not isBeingLookedAt and not isLookingBack and not shouldLookAtDirection then
				if currentBehavior == "follow" and wasInRadius then
					StatusLabel.Text = string.format("Following in radius: %.0f studs", distance)
				elseif not wasInRadius then
					StatusLabel.Text = string.format("Following: %.0f studs away", distance)
				end
				StatusLabel.TextColor3 = Color3.fromRGB(100, 200, 255)
			end
			lastDistanceUpdate = currentTime
		end

		-- Check if target is looking at follower (22 degrees) AND within 8 studs
		local targetLooking = isTargetLookingAtFollower(targetRoot, humanoidRootPart)

		if distance <= STOP_DISTANCE and targetLooking then
			-- STEP 1: Victim is looking at follower (within 22 degrees)
			if not isBeingLookedAt then
				-- Just started being looked at
				isBeingLookedAt = true
				lookStartTime = currentTime
				shouldLookAtDirection = false
				StatusLabel.Text = string.format("Target looking at you: %.0f studs", distance)
				StatusLabel.TextColor3 = Color3.fromRGB(255, 200, 100)
			else
				-- Continue being looked at
				local lookDuration = currentTime - lookStartTime

				-- STEP 2: After 2 seconds, look back at target
				if lookDuration >= LOOK_DURATION and not isLookingBack then
					isLookingBack = true
					shouldLookAtDirection = false
					StatusLabel.Text = string.format("Looking back at target: %.0f studs", distance)
					StatusLabel.TextColor3 = Color3.fromRGB(255, 150, 100)
				end

				-- Look at target if we're in step 2
				if isLookingBack then
					lookAtPosition(character, targetRoot.Position)
				end
			end
			lookAwayStartTime = 0  -- Reset look away timer
		else
			-- Target is NOT looking at follower (outside 22 degrees)
			if isBeingLookedAt then
				-- Target just looked away
				isBeingLookedAt = false

				if isLookingBack then
					-- STEP 3: Start 1.5-second timer after target looks away
					lookAwayStartTime = currentTime
					StatusLabel.Text = string.format("Target looked away (1.5s): %.0f studs", distance)
					StatusLabel.TextColor3 = Color3.fromRGB(255, 180, 100)
				else
					-- Wasn't looking back yet, just reset
					isLookingBack = false
					shouldLookAtDirection = false
				end
			end

			-- Handle the 1.5-second timer after target looks away
			if lookAwayStartTime > 0 then
				local timeSinceLookAway = currentTime - lookAwayStartTime

				if timeSinceLookAway < LOOK_AWAY_DELAY then
					-- Still in 1.5-second delay
					local timeLeft = math.ceil(LOOK_AWAY_DELAY - timeSinceLookAway)
					StatusLabel.Text = string.format("Waiting (1.5s): %.1fs, %.0f studs", LOOK_AWAY_DELAY - timeSinceLookAway, distance)
					StatusLabel.TextColor3 = Color3.fromRGB(255, 180, 100)
				else
					-- 1.5 seconds passed, look at target's direction briefly (0.5 seconds)
					if not shouldLookAtDirection then
						-- Start looking at target's direction
						shouldLookAtDirection = true
						lookAtDirectionTime = currentTime
					end

					-- Look at where target is CURRENTLY looking for 0.5 seconds
					if shouldLookAtDirection then
						local timeLookingAtDirection = currentTime - lookAtDirectionTime

						if timeLookingAtDirection < LOOK_AT_DIRECTION_BRIEFLY then
							-- Get a point 20 studs in front of where target is looking
							local pointToLookAt = getPointInTargetLookDirection(targetRoot, 20)
							lookAtPosition(character, pointToLookAt)

							StatusLabel.Text = string.format("Looking where target is facing: %.0f studs", distance)
							StatusLabel.TextColor3 = Color3.fromRGB(255, 150, 100)
						else
							-- 0.5 seconds passed, stop everything and return to normal
							isLookingBack = false
							shouldLookAtDirection = false
							lookAwayStartTime = 0
							StatusLabel.Text = string.format("Following: %.0f studs away", distance)
							StatusLabel.TextColor3 = Color3.fromRGB(100, 200, 255)
						end
					end
				end
			end
		end

		-- Regular following behavior
		if not isLookingBack and not shouldLookAtDirection then
			-- Check if direct path is blocked
			local ray = Ray.new(humanoidRootPart.Position, (targetRoot.Position - humanoidRootPart.Position).Unit * math.min(distance, 100))
			local hitPart, hitPosition = workspace:FindPartOnRayWithIgnoreList(ray, {character, targetChar})

			local isPathBlocked = hitPart and hitPart.CanCollide

			if isPathBlocked then
				-- Path blocked! Clear old stored positions that might lead through wall
				STORED_POSITIONS = {}
				StatusLabel.Text = string.format("Path blocked - clearing history: %.0f studs", distance)
				StatusLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
			end

			if distance <= STOP_DISTANCE then
				-- Stop moving when within 8 studs
				humanoid:MoveTo(humanoidRootPart.Position)
				if not isBeingLookedAt and not isLookingBack and not shouldLookAtDirection then
					StatusLabel.TextColor3 = Color3.fromRGB(120, 255, 120)
				end
				return
			end

			table.insert(STORED_POSITIONS, {
				position = targetRoot.Position,
				isJumping = targetHumanoid:GetState() == Enum.HumanoidStateType.Jumping or targetHumanoid:GetState() == Enum.HumanoidStateType.Freefall,
				timestamp = tick()
			})

			if #STORED_POSITIONS > MAX_HISTORY then
				table.remove(STORED_POSITIONS, 1)
			end

			if #STORED_POSITIONS >= MIMIC_DELAY then
				local mimicIndex = math.max(1, #STORED_POSITIONS - MIMIC_DELAY + 1)
				local storedData = STORED_POSITIONS[mimicIndex]

				if storedData then
					humanoid:MoveTo(storedData.position)

					if storedData.isJumping and not humanoid.Jump then
						humanoid.Jump = true
						StatusLabel.Text = string.format("Jumping: %.0f studs away", distance)
						StatusLabel.TextColor3 = Color3.fromRGB(255, 150, 100)
					else
						StatusLabel.TextColor3 = Color3.fromRGB(100, 200, 255)
					end
				end
			else
				lastUpdate = lastUpdate + deltaTime

				if lastUpdate >= UPDATE_RATE then
					lastUpdate = 0

					if distance > MAX_DISTANCE then
						local path = PathfindingService:CreatePath({
							AgentRadius = 2,
							AgentHeight = 5,
							AgentCanJump = true,
							AgentJumpHeight = 7.5,
							AgentMaxSlope = 45
						})

						local success = pcall(function()
							path:ComputeAsync(humanoidRootPart.Position, targetRoot.Position)
						end)

						if success and path.Status == Enum.PathStatus.Success then
							local waypoints = path:GetWaypoints()
							if #waypoints > 1 then
								humanoid:MoveTo(waypoints[2].Position)
							end
						else
							humanoid:MoveTo(targetRoot.Position)
						end
					else
						-- EVEN WHEN CLOSE, USE STORED POSITIONS IF AVAILABLE
						if #STORED_POSITIONS > 0 then
							local lastStored = STORED_POSITIONS[#STORED_POSITIONS]
							humanoid:MoveTo(lastStored.position)
						else
							humanoid:MoveTo(targetRoot.Position)
						end
					end
				end
			end
		end
	end)
end

local function updateSearchPreview()
	local searchText = SearchBar.Text

	if searchText == "" then
		if not isFollowing then
			StatusLabel.Text = "Ready"
			StatusLabel.TextColor3 = Color3.fromRGB(120, 255, 120)
		end
		return
	end

	local foundPlayer = findPlayer(searchText)

	if foundPlayer then
		if not isFollowing then
			StatusLabel.Text = "Found: " .. foundPlayer.DisplayName .. " (@" .. foundPlayer.Name .. ")"
			StatusLabel.TextColor3 = Color3.fromRGB(120, 255, 120)
		end
	else
		if not isFollowing then
			StatusLabel.Text = "No player found"
			StatusLabel.TextColor3 = Color3.fromRGB(255, 120, 120)
		end
	end
end

SearchBar:GetPropertyChangedSignal("Text"):Connect(updateSearchPreview)

FollowButton.MouseButton1Click:Connect(function()
	local searchText = SearchBar.Text

	if searchText == "" then
		StatusLabel.Text = "Please enter a player name"
		StatusLabel.TextColor3 = Color3.fromRGB(255, 200, 100)
		return
	end

	local foundPlayer = findPlayer(searchText)

	if foundPlayer then
		targetPlayer = foundPlayer
		isFollowing = true
		startFollowing()
		StatusLabel.Text = "Following: " .. foundPlayer.DisplayName
		StatusLabel.TextColor3 = Color3.fromRGB(100, 200, 255)
		print("Started following:", foundPlayer.Name)
	else
		StatusLabel.Text = "Player not found"
		StatusLabel.TextColor3 = Color3.fromRGB(255, 120, 120)
	end
end)

CancelButton.MouseButton1Click:Connect(function()
	stopFollowing()
	StatusLabel.Text = "Stopped following"
	StatusLabel.TextColor3 = Color3.fromRGB(255, 200, 100)
	SearchBar.Text = ""
	print("Stopped following")
end)

Players.PlayerRemoving:Connect(function(removedPlayer)
	if removedPlayer == targetPlayer then
		stopFollowing()
		StatusLabel.Text = "Target player left the game"
		StatusLabel.TextColor3 = Color3.fromRGB(255, 200, 100)
	end
end)

local Intro = "Enhanced Follow Player GUI loaded!"
local Madeby = "Made by ZPloak"
local Credits = "WIth the help of..."
local AI = "Claude & Deepseek"

print(Intro)
task.wait(0.1)
print(Madeby)
task.wait(0.1)
print(Credits)
task.wait(0.1)
print(AI)
